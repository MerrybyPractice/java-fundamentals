/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package basiclibrary;

import javafx.util.Pair;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;


public class Library {
    public static void main(String[] args) {

//        //test lines for roll
//        //odd number
//        System.out.println(Arrays.toString(roll(7)));
//        //even number
//        System.out.println(Arrays.toString(roll(14)));
//        //zero
//        System.out.println(Arrays.toString(roll(0)));
//
//        //test lines for containsDuplicates
//
//        //should return true
//        int[] dupNextToEachOther = new int[]{1, 2, 5, 6, 6, 8};
//        System.out.println(containsDuplicates(dupNextToEachOther));
//
//
//        //should return true
//        int[] dupFarApart = new int[]{9, 3, 6, 2, 4, 5, 3, 1,};
//        System.out.println(containsDuplicates(dupFarApart));
//
//        //should return false
//        int[] noDup = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9};
//        System.out.println(containsDuplicates(noDup));
//
//        //test lines for calculatingAverages
//        int[] allOneNumber = new int[]{1, 1, 1, 1};
//        System.out.println(calculatingAverages(allOneNumber));
//
//        int[] manyNumbers = new int[]{7, 8, 3, 5, 2, 4, 7, 5, 2, 4, 6, 8, 6, 2, 3};
//        System.out.println(calculatingAverages(manyNumbers));
//
//        int[] empty = new int[]{};
//        System.out.println(calculatingAverages(empty));
//
//        int[] oneNumber = new int[]{4};
//        System.out.println(calculatingAverages(oneNumber));

        List<String> votes = new ArrayList<>();
        votes.add("Bush");
        votes.add("Bush");
        votes.add("Bush");
        votes.add("Shrub");
        votes.add("Hedge");
        votes.add("Shrub");
        votes.add("Bush");
        votes.add("Hedge");
        votes.add("Bush");

        String winner = tally(votes);
        System.out.println(winner + " received the most votes!");
    }

    public boolean someLibraryMethod() {
        return true;
    }

    public static int[] roll(int n) {
        int[] rolls = new int[n];

        for (int i = 0; i < n; i++) {
            int num = (int) ((Math.random() * ((6 - 1) + 1)) + 1);
            rolls[i] = num;
        }
        return rolls;
    }

    public static boolean containsDuplicates(int[] inputArray) {
        Arrays.sort(inputArray);

        boolean returnValue = false;
        boolean flag = false;

        for (int i = 0; i < inputArray.length; i++) {
            for (int j = i + 1; j < inputArray.length; j++) {
                if (flag == false) {
                    if (inputArray[i] == inputArray[j]) {
                        returnValue = true;
                        flag = true;
                    } else {
                        returnValue = false;
                    }
                }
            }
        }
        return returnValue;
    }

    public static int calculatingAverages(int[] inputArray) {

        int n = 0;

        for (int i = 0; i < inputArray.length; i++) {

            n = n + inputArray[i];
        }
        return n / inputArray.length;
    }

    public static String analyzingWeatherData(int[][] weeklyMonthTemperatures) {
        HashSet<Integer> uniqueWeather = new HashSet<>();
        for (int i = 0; i < weeklyMonthTemperatures.length; i++) {
            for (int j = 0; j < weeklyMonthTemperatures.length; j++)
                uniqueWeather.add(weeklyMonthTemperatures[i][j]);
        }
        //broke out min max function as it was multi-use and made analyzingWeatherData unwieldy
        Pair<Integer, Integer> minMax = (returnMinMaxDouble(weeklyMonthTemperatures));

        //I know min will always be the key in the pair and max will always be the value in the pair because of the order returnMinMaxDouble returns the pair in.
        int min = minMax.getKey();
        System.out.println("Low:" + min);

        //max will always be the value in the pair due to the order of returnMinMaxDouble as well(for clarity)
        int max = minMax.getValue();
        System.out.println("High:" + max);

        for (int k = min; k < max; k += 1) {

            if (!(uniqueWeather.contains(k))) {
                System.out.println("Never saw temperature:" + k);
            }

        }

        return "Low: " + min + " High: " + max;
    }

    public static Pair<Integer, Integer> returnMinMaxDouble(int[][] iterableArray) {

        Integer[] singleDimensionalArray = new Integer[(iterableArray.length) * (iterableArray[0].length)];

        int i = 0;

        for (int j = 0; j < iterableArray.length; j++) {
            for (int l = 0; l < iterableArray[j].length; l++) {
                singleDimensionalArray[i] = iterableArray[j][l];
                i++;
            }
        }

        Arrays.sort(singleDimensionalArray);

        int min = singleDimensionalArray[0];
        int max = singleDimensionalArray[singleDimensionalArray.length - 1];

        Pair<Integer, Integer> returnValue = new Pair<>(min, max);

        return returnValue;
    }

    public static String tally(List<String> votes) {

        Object[] votesArray = votes.toArray();

        String[] stringyVotesArray = new String[votesArray.length];

        for (int j = 0; j < votesArray.length; j++) {
            stringyVotesArray[j] = (String) votesArray[j];
        }

        Arrays.sort(stringyVotesArray);
        //sort so each unique type of string is next to each other

        Integer numVotes = 0;

        Pair<String, Integer> winner = null;

        int currentCandidate = 0;
        int previousCandidate = 0;

        for (int i = 0; i < stringyVotesArray.length; i++) {

            numVotes++;

            if ((i != votesArray.length - 1) && !(votesArray[i].equals(votesArray[i + 1]))) {

                currentCandidate++;

                if (currentCandidate > previousCandidate) {
                    winner = new Pair<>(stringyVotesArray[i], numVotes);
                    previousCandidate = currentCandidate;
                    currentCandidate = 0;
                } else {

                    previousCandidate = currentCandidate;

                    currentCandidate = 0;
                }
                numVotes = 0;
            }

        }
        return winner.getKey();
    }
}



